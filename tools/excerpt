#! /usr/bin/awk --exec
#-*- awk -*-

# TODO
# - extract callouts
#  - write line numbers or on corresponding lines?

BEGIN {
    program_name = "excerpt";

    comment_start = "\\/\\*";
    excerpt_start = "@beginexcerpt";
    excerpt_end = "@endexcerpt";
    callout = "@callout";

    excerpt_start_pat = comment_start "[[:blank:]]*" excerpt_start "[[:blank:]]+";
    excerpt_end_pat = comment_start "[[:blank:]]*" excerpt_end "[[:blank:]]+";
    callout_pat = "[[:blank:]]*" comment_start "[[:blank:]]+" callout "[[:blank:]]+([[:alnum:]_]+)([[:blank:]]+([[:alnum:]_]+))?[[:blank:]]+"

    outdent = 0;
    excerpts_dir = "";

    Opterr = 1;
    Optind = 1;

    while ((c = getopt(ARGC, ARGV, "vhod:")) != -1) {
        if (c == "v") {
            version_etc();
            exit(0);
        } else if (c == "h") {
            usage(0);
        } else if (c == "o") {
            outdent = 1;
        } else if (c == "d") {
            excerpts_dir = Optarg;
        }
    }

    if (Optind != ARGC - 1) {
        usage(1);
    }
    for (i = 1; i < Optind; i++)
        ARGV[i] = "";

    infile = ARGV[Optind];
    if (excerpts_dir == "") {
        excerpts_dir = dirname(infile) "/excerpts";
    }

    system("mkdir -p " excerpts_dir);

    excerpts_base = excerpts_basename(excerpts_dir, infile);
    excerpts_ext = ".exc"
}

$0 ~ excerpt_start_pat {
    if (match($0, excerpt_start_pat "([[:alnum:]_]+)", m)) {
        e = m[1];
        fn = excerpts_base e excerpts_ext;
        excerpts[e] = fn;
        blanks[e] = 10000;
        lines[e] = 0;
        next;
    }
}

$0 ~ excerpt_end_pat {
    if (match($0, excerpt_end_pat "([[:alnum:]_]+)", m)) {
        e = m[1];
        if (excerpts[e]) {
            all_excerpts[e] = excerpts[e];
            close(excerpts[e]);
            delete excerpts[e];
            delete lines[e];
            next;
        }
    }
}

$0 ~ callout_pat {
    match($0, callout_pat, m);
    $0 = substr($0, 0, RSTART - 1);
    print; ### REMOVE
    co = m[1];
    ex = m[3];
    for (e in excerpts) {
        if (!ex || ex == e) {
            print e ":" lines[e] ": " co;
        }
    }
}

{
    for (e in excerpts) {
        if (match($0, /^[[:blank:]]+/)) {
            bl = RLENGTH;
            if (blanks[e] > bl) {
                blanks[e] = bl;
            }
        }
        print > excerpts[e];
        lines[e]++;
    }
}

END {
    if (outdent) {
        for (e in all_excerpts) {
            cmd = "sed -i 's/^ \\{" blanks[e] "\\}//' " all_excerpts[e];
            system(cmd);
        }
    }
}


function version_etc()
{
    print "excerpt 0.1"
    print "Copyright (C) 2009 Michael Schuerig";
    print "\
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>\n\
This is free software: you are free to change and redistribute it.\n\
There is NO WARRANTY, to the extent permitted by law.";
}

function usage(status)
{
    if (status != 0) {
        printf("Try %s -h for more information.\n", program_name) > "/dev/stderr";
    } else {
        printf("Usage: %s [OPTION]... FILE\n", program_name);
        print  "  -d                       output directory for excerpts"
        print  "  -o                       outdent; remove indentation"
        print  "  -h                       display this help text and exit"
        print  "  -v                       output version information and exit"
    }
    exit(status);
}

function excerpts_basename(excerpts_dir, infile,  _ebn)
{
    _ebn = basename(infile);
    gsub(/[[:space:][:punct:]]/, "_", _ebn);
    return excerpts_dir "/" _ebn "_";
}

function dirname(fn,  _dir)
{
    _dir = fn;
    sub(/\/[^/]+/, "", _dir);
    return _dir;
}

function basename(fn,  _bn)
{
    _bn = fn;
    sub(/.*\//, "", _bn);
    return _bn;
}

# getopt.awk --- do C library getopt(3) function in awk
#
# Arnold Robbins, arnold@gnu.org, Public Domain
#
# Initial version: March, 1991
# Revised: May, 1993

# External variables:
#    Optind -- index in ARGV of first nonoption argument
#    Optarg -- string value of argument to current option
#    Opterr -- if nonzero, print our own diagnostic
#    Optopt -- current option letter

# Returns:
#    -1     at end of options
#    ?      for unrecognized option
#    <c>    a character representing the current option

# Private Data:
#    _opti  -- index in multi-flag option, e.g., -abc
function getopt(argc, argv, options,    thisopt, i)
{
    if (length(options) == 0)    # no options given
        return -1

    if (argv[Optind] == "--") {  # all done
        Optind++
        _opti = 0
        return -1
    } else if (argv[Optind] !~ /^-[^: \t\n\f\r\v\b]/) {
        _opti = 0
        return -1
    }
    if (_opti == 0)
        _opti = 2
    thisopt = substr(argv[Optind], _opti, 1)
    Optopt = thisopt
    i = index(options, thisopt)
    if (i == 0) {
        if (Opterr)
            printf("%c -- invalid option\n",
                                  thisopt) > "/dev/stderr"
        if (_opti >= length(argv[Optind])) {
            Optind++
            _opti = 0
        } else
            _opti++
        return "?"
    }
    if (substr(options, i + 1, 1) == ":") {
        # get option argument
        if (length(substr(argv[Optind], _opti + 1)) > 0)
            Optarg = substr(argv[Optind], _opti + 1)
        else
            Optarg = argv[++Optind]
        _opti = 0
    } else
        Optarg = ""
    if (_opti == 0 || _opti >= length(argv[Optind])) {
        Optind++
        _opti = 0
    } else
        _opti++
    return thisopt
}
# BEGIN {
#     Opterr = 1    # default is to diagnose
#     Optind = 1    # skip ARGV[0]
#
#     # test program
#     if (_getopt_test) {
#         while ((_go_c = getopt(ARGC, ARGV, "ab:cd")) != -1)
#             printf("c = <%c>, optarg = <%s>\n",
#                                        _go_c, Optarg)
#         printf("non-option arguments:\n")
#         for (; Optind < ARGC; Optind++)
#             printf("\tARGV[%d] = <%s>\n",
#                                     Optind, ARGV[Optind])
#     }
# }
